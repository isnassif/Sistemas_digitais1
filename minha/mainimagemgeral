module mainimagemgeral (
    input vga_reset,
    input clk_50MHz,
    input [9:0] SW,
    output [9:0] next_x,
    output [9:0] next_y,
    output hsyncm,
    output vsyncm,
    output [7:0] redm,
    output [7:0] greenm,
    output [7:0] bluem,
    output blank,
    output sync,
    output clks
);


		
	reg [7:0] memoria_entrada [0:3];
	
	

    // --- Geração do clock VGA ---
    // A maioria dos monitores VGA (640x480) precisa de um clock de 25.175 MHz.
    // Usar um clock de 50MHz dividido por 2 (gerado abaixo) é uma solução comum e simples.
    reg clk_vga = 0;
    always @(posedge clk_50MHz) begin
        clk_vga <= ~clk_vga;
    end

    // --- Sinais internos para o fluxo de dados ---
    // Estes sinais conectam os módulos de processamento e VGA.
    // Eles representam o pixel e os sinais de controle do fluxo.
    wire [7:0] pixel_saida_zoom;
    wire pixel_saida_zoom_valido;
    wire linha_saida_zoom_valida;
    
    // O endereço para a ROM precisa ser gerado de forma síncrona
    // com o módulo de zoom. Como o módulo de zoom consome os pixels de entrada
    // um a um, o contador de endereço para a ROM deve avançar a cada
    // pixel consumido.
    reg [18:0] rom_address;
    
    // --- Instanciação da Memória ROM da Imagem ---
    // Esta ROM contém a imagem original (640x480 pixels).
    // O endereço é gerado por um contador interno ou pela sua lógica de leitura.
    wire [7:0] pixel_da_rom;
    
    initial begin
        memoria_entrada[0] = 8'd1;
        memoria_entrada[1] = 8'd2;
        memoria_entrada[2] = 8'd3;
        memoria_entrada[3] = 8'd4;
		  rom_address = 19'd0;
    end

    // --- Instanciação do Módulo de Replicação de Pixel ---
    // Este módulo pega o fluxo de pixels da ROM e gera o fluxo de pixels replicados.
    // Você deve ajustar os parâmetros para a sua imagem (640x480).
    rep_pixel_stream_pt #(
        .FATOR(2), // Exemplo de FATOR de 2x
        .RESOLUCAO_H_ORIGINAL(2)
    ) zoom_in_module (
        .clk(clk_vga),
        .rst(vga_reset),
        
        // Entradas: recebem os pixels da ROM
        .i_pixel_entrada(pixel_da_rom),
        .i_pixel_entrada_valido(1'b1), // Supondo que a ROM sempre fornece um pixel válido
        .i_linha_entrada_valida(1'b0), // O controle de linha virá de uma lógica mais complexa
        
        // Saídas: fornecem os pixels ampliados para o VGA
        .o_pixel_saida(pixel_saida_zoom),
        .o_pixel_saida_valido(pixel_saida_zoom_valido),
        .o_linha_saida_valida(linha_saida_zoom_valida)
    );

    // --- Lógica para o Endereço da ROM ---
    // O endereço da ROM deve avançar a cada pixel de entrada que o módulo de zoom
    // precisa para processar. Como a lógica de zoom consome um pixel de entrada
    // por vez (no estado de escrita), o endereço da ROM deve ser incrementado.
    always @(posedge clk_vga) begin
        if (vga_reset) begin
            rom_address <= 0;
        end else if (zoom_in_module.estado == ESTADO_ESCRITA) begin
             rom_address <= rom_address + 1;
        end
    end
    
    // --- Instanciação do Driver VGA ---
    // O driver VGA agora recebe o fluxo de dados processado pelo módulo de zoom.
    vga_driver draw (
        .clock(clk_vga),
        .reset(vga_reset),
        .color_in(pixel_saida_zoom), // Conecta a saída do módulo de zoom
        .hsync(hsyncm),
        .vsync(vsyncm),
        .red(redm),
        .green(greenm),
        .blue(bluem),
        .next_x(next_x),
        .next_y(next_y),
        .sync(sync),
        .clk(clks),
        .blank(blank)
    );

endmodule
