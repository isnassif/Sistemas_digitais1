module mediablocos #(
    parameter LARGURA    = 160,
    parameter ALTURA     = 120,
    parameter FATOR      = 2,
    parameter NEW_LARG   = LARGURA / FATOR,
    parameter NEW_ALTURA = ALTURA  / FATOR
)(
    input              clk,
    input              reset,
    output wire [18:0] rom_addr,
    input       [7:0]  rom_data,
    output reg  [18:0] ram_wraddr,
    output reg  [7:0]  ram_data,
    output reg         ram_wren,
    output reg         done
);
    
    reg [7:0] linha, di;
    reg [8:0] coluna, dj;
    reg [9:0] soma_bloco;
    reg [7:0] rom_data_reg;

    
    reg [1:0] pixel_count; 

    // O assign para o rom_addr calcula o endereço de leitura na imagem original
    assign rom_addr = (linha + di) * LARGURA + (coluna + dj);

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            linha        <= 0; 
            coluna       <= 0; 
            di           <= 0; 
            dj           <= 0;
            soma_bloco   <= 0;
            rom_data_reg <= 0;
            ram_wren     <= 1'b0;
            done         <= 1'b0;
            ram_wraddr   <= 0;
            pixel_count  <= 0;
        end else begin
            ram_wren <= 1'b0;

            rom_data_reg <= rom_data;

            if (!done) begin
               
                //    Usamos rom_data_reg, que é o dado do ciclo ANTERIOR, para manter a sincronia.
                soma_bloco <= soma_bloco + rom_data_reg;

                //    Isso garante que vamos varrer o bloco 2x2 na ROM.
                if (dj == FATOR - 1) begin
                    dj <= 0;
                    di <= di + 1;
                end else begin
                    dj <= dj + 1;
                end

                //    Verificamos se o bloco terminou usando o contador.
                if (pixel_count == (FATOR * FATOR) - 1) begin
                    
                    ram_wren <= 1'b1;
                    
                    ram_data <= (soma_bloco + rom_data_reg) >> 2; // >> 2 é o mesmo que dividir por 4
                    
                    ram_wraddr <= (linha / FATOR) * NEW_LARG + (coluna / FATOR);
                    
                    soma_bloco <= 0; // Zera a soma para o próximo bloco
                    pixel_count <= 0; // Zera o contador de pixels

                    if (coluna == LARGURA - FATOR) begin
                        coluna <= 0;
                        if (linha == ALTURA - FATOR) begin
                            linha <= 0;
                            done <= 1'b1; // Acabou tudo!
                        end else begin
                            linha <= linha + FATOR;
                        end
                    end else begin
                        coluna <= coluna + FATOR;
                    end
                    
                    // Reseta os ponteiros internos para o início do próximo bloco
                    di <= 0;
                    dj <= 0;

                end else begin
                    // Se não for o fim do bloco, apenas incrementa o contador de pixels.
                    pixel_count <= pixel_count + 1;
                end
            end
        end
    end

endmodule

module mainv (
    input vga_reset,
    input clk_50MHz,
    input switch,      

    output [9:0] next_x,
    output [9:0] next_y,
    output hsyncm,
    output vsyncm,
    output [7:0] redm,
    output [7:0] greenm,
    output [7:0] bluem,
    output blank,
    output sync,
    output clks
);

    // Clock VGA (25 MHz)
    reg clk_vga = 0;
    always @(posedge clk_50MHz) begin
        clk_vga <= ~clk_vga;
    end

    // VGA driver
    vga_driver draw (
        .clock(clk_vga),
        .reset(vga_reset),
        .color_in(color_in), // A lógica deste sinal será alterada
        .next_x(next_x),
        .next_y(next_y),
        .hsync(hsyncm),
        .vsync(vsyncm),
        .sync(sync),
        .clk(clks),
        .blank(blank),
        .red(redm),
        .green(greenm),
        .blue(bluem)
    );

    // Parâmetros da imagem ORIGINAL
    parameter IMG_W = 160;
    parameter IMG_H = 120;
    
    // Parâmetros da imagem de SAÍDA (PROCESSADA)
    parameter FATOR = 2;
    parameter IMG_W_SAIDA = IMG_W / FATOR;  // 80
    parameter IMG_H_SAIDA = IMG_H / FATOR;  // 60

    // --- LÓGICA PARA IMAGEM PROCESSADA (80x60) ---
    wire [9:0] x_offset_proc = (640 - IMG_W_SAIDA) / 2;
    wire [9:0] y_offset_proc = (480 - IMG_H_SAIDA) / 2;
    wire in_image_proc = (next_x >= x_offset_proc && next_x < x_offset_proc + IMG_W_SAIDA) &&
                         (next_y >= y_offset_proc && next_y < y_offset_proc + IMG_H_SAIDA);

    reg [18:0] ram_rd_addr;
    always @(posedge clk_vga) begin
        if (in_image_proc)
            ram_rd_addr <= (next_y - y_offset_proc) * IMG_W_SAIDA + (next_x - x_offset_proc);
        else
            ram_rd_addr <= 0;
    end

    wire [7:0] processed_pixel;
    ram2port framebuffer (
        .clock(clk_vga),
        .data(wr_data),
        .rdaddress(ram_rd_addr),
        .wraddress(wr_addr),
        .wren(wr_en),
        .q(processed_pixel)
    );
    
    // --- LÓGICA PARA IMAGEM ORIGINAL (160x120) - NOVO ---
    wire [9:0] x_offset_orig = (640 - IMG_W) / 2;
    wire [9:0] y_offset_orig = (480 - IMG_H) / 2;
    wire in_image_orig = (next_x >= x_offset_orig && next_x < x_offset_orig + IMG_W) &&
                         (next_y >= y_offset_orig && next_y < y_offset_orig + IMG_H);

    reg [18:0] rom_rd_addr_display;
    always @(posedge clk_vga) begin
        if (in_image_orig)
            rom_rd_addr_display <= (next_y - y_offset_orig) * IMG_W + (next_x - x_offset_orig);
        else
            rom_rd_addr_display <= 0;
    end
    

    // --- MÓDULOS DE MEMÓRIA ---

    // ROM para o processador de média
    wire [7:0] rom_pixel_proc;
    wire [18:0] rom_addr_proc;
    mem rom_image_proc (
        .address(rom_addr_proc),
        .clock(clk_vga),
        .q(rom_pixel_proc)
    );

    // SEGUNDA INSTÂNCIA DA ROM para o display da imagem original - NOVO
    wire [7:0] rom_pixel_display;
    mem rom_image_display (
        .address(rom_rd_addr_display),
        .clock(clk_vga),
        .q(rom_pixel_display)
    );

    wire [18:0] wr_addr;
    wire [7:0] wr_data;
    wire wr_en;
    wire copy_done;
    mediablocos media_proc (
        .clk(clk_vga),
        .reset(vga_reset),
        .rom_addr(rom_addr_proc),
        .rom_data(rom_pixel_proc),
        .ram_wraddr(wr_addr),
        .ram_data(wr_data),
        .ram_wren(wr_en),
        .done(copy_done)
    );

    wire [7:0] color_in;
    wire [7:0] final_processed_pixel = (in_image_proc) ? processed_pixel : 8'd0;
    wire [7:0] final_original_pixel  = (in_image_orig) ? rom_pixel_display : 8'd0;

    // O switch atua como um MUX: 0 para processado, 1 para original.
    assign color_in = (switch == 1'b0) ? final_processed_pixel : final_original_pixel;

endmodule
